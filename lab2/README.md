# Графический интерфейс интеллектуальных систем. Графический редактор

<details>
  <summary>Лаб 1</summary>
  
## Цель
Разработать элементарный графический редактор, реализующий построение отрезков с помощью алгоритма ЦДА, целочисленного алгоритма Брезенхема и алгоритма Ву. Вызов способа генерации отрезка задается из пункта меню и доступно через панель инструментов «Отрезки». В редакторе кроме режима генерации отрезков в пользовательском окне должен быть предусмотрен отладочный режим, где отображается пошаговое решение на дискретной сетке.

## Описание алгоритмов
### Цифровой Дифференциальный Анализатор
Цифровой дифференциальный анализатор (ЦДА) – это алгоритм, основанный на аппроксимации прямой линии путем равномерного приращения координат. Он разбивает отрезок на равные шаги по одной из координат и вычисляет соответствующие значения другой координаты.

### Алгоритм Брезенхема
Алгоритм Брезенхема основан на выборе оптимального пикселя с использованием целочисленных вычислений. В отличие от ЦДА, он исключает необходимость работы с дробными числами, используя пошаговое накопление ошибки, чтобы принять решение о том, какой пиксель закрасить на следующем шаге.

### Алгоритм Ву
Алгоритм Ву предназначен для построения сглаженных (антиалиасинговых) линий. В отличие от Брезенхема, который выбирает один пиксель на каждом шаге, Ву использует два соседних пикселя, назначая им разные уровни яркости, чтобы сгладить границы линии и уменьшить эффект "ступенек" (aliasing).

## Интерфейс
![image](https://github.com/user-attachments/assets/212a9924-8095-4518-ab6f-4a810d94fda1)


## Реализация
Функция отрисовки точек из методички по алгоритму ЦДА:
```Python
    def execute(self, a, b, canvas, debugger=None):
        x1, y1 = a
        x2, y2 = b

        dx = x2 - x1
        dy = y2 - y1
        length = max(abs(dx), abs(dy))

        dx /= length
        dy /= length

        x = x1 + 0.5 * (1 if dx > 0 else -1 if dx < 0 else 0)
        y = y1 + 0.5 * (1 if dy > 0 else -1 if dy < 0 else 0)

        if debugger:
            debugger.record_step(int(x), int(y))

        for _ in range(int(length)):
            x += dx
            y += dy
            if debugger:
                debugger.record_step(int(x), int(y))
            else:
                self.plot(canvas, int(x), int(y))
```
Функция отрисовки точек по алгоритму Брезенхема:
```Python
    def execute(self, a, b, canvas, debugger=None):
        x1, y1 = a
        x2, y2 = b

        dx = abs(x2 - x1)
        dy = abs(y2 - y1)

        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1

        if dx > dy:
            e = 2 * dy - dx
            while x1 != x2:
                if debugger:
                    debugger.record_step(int(x1), int(y1))
                else:
                    self.plot(canvas, int(x1), int(y1), "black")
                if e >= 0:
                    y1 += sy
                    e -= 2 * dx
                x1 += sx
                e += 2 * dy
        else:
            e = 2 * dx - dy
            while y1 != y2:
                if debugger:
                    debugger.record_step(int(x1), int(y1))
                else:
                    self.plot(canvas, int(x1), int(y1), "black")
                if e >= 0:
                    x1 += sx
                    e -= 2 * dy
                y1 += sy
                e += 2 * dx

        if debugger:
            debugger.record_step(int(x1), int(y1))
        else:
            self.plot(canvas, int(x1), int(y1), "black")

```
Функция отрисовки точек по алгоритму Ву:
```Python
    def execute(self, a, b, canvas, debugger=None):
        """Алгоритм Ву с отладкой, без сглаживания для вертикальных и горизонтальных линий."""
        x1, y1 = a
        x2, y2 = b

        dx = abs(x2 - x1)
        dy = abs(y2 - y1)

        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1

        # Проверка на вертикальную линию (без сглаживания)
        if dx == 0:
            for y in range(y1, y2 + sy, sy):
                if debugger:
                    debugger.record_step(x1, y, 1.0)
                else:
                    self.plot(canvas, x1, y, 1.0)
            return

        # Проверка на горизонтальную линию (без сглаживания)
        if dy == 0:
            for x in range(x1, x2 + sx, sx):
                if debugger:
                    debugger.record_step(x, y1, 1.0)
                else:
                    self.plot(canvas, x, y1, 1.0)
            return

        # Для остальных линий используем сглаживание Ву
        if dx > dy:
            gradient = dy / dx
            y = y1 + 0.5
            for x in range(x1, x2 + sx, sx):
                y_int = int(y)
                frac = y - y_int  # Дробная часть

                if debugger:
                    debugger.record_step(x, y_int, 1 - frac)
                    debugger.record_step(x, y_int + sy, frac)
                else:
                    self.plot(canvas, x, y_int, 1 - frac)
                    self.plot(canvas, x, y_int + sy, frac)

                y += gradient * sy
        else:
            gradient = dx / dy
            x = x1 + 0.5
            for y in range(y1, y2 + sy, sy):
                x_int = int(x)
                frac = x - x_int  # Дробная часть

                if debugger:
                    debugger.record_step(x_int, y, 1 - frac)
                    debugger.record_step(x_int + sx, y, frac)
                else:
                    self.plot(canvas, x_int, y, 1 - frac)
                    self.plot(canvas, x_int + sx, y, frac)

                x += gradient * sx

        if debugger:
            debugger.record_step(x2, y2, 1.0)  # Последний пиксель
        else:
            self.plot(canvas, x2, y2, 1.0)
```

## Вывод
В результате реализации графического редактора, использующего алгоритмы построения отрезков (ЦДА, Брезенхема и Ву), была создана система, обеспечивающая интерактивное рисование отрезков с возможностью просмотра пошагового процесса.

</details>

<details>
  <summary>Лаб 2</summary>
  
## Цель
Разработать элементарный графический редактор, реализующий построение линий второго порядка. Вызов способа генерации линии второго порядка задается из пункта меню и доступно через панель инструментов «Линии 2-го порядка». В редакторе кроме режима генерации линий второго порядка в пользовательском окне должен быть предусмотрен отладочный режим, где отображается пошаговое решение на дискретной сетке.

## Описание алгоритмов
### Алгоритм построения окружности
Алгоритм использует метод Брезенхэма для построения окружности. Считывает две точки(x,y), вычисляет по ним радиус и вычисляет точки окружности в одном октанте, а затем симметрично отражает их в остальные семь октантов. Решающая переменная d определяет, какую точку выбрать на следующем шаге. Для каждой вычисленной точки добавляются восемь симметричных точек относительно центра окружности (cx, cy).

$d = 3 - 2 * radius$

### Алгоритм построения эллипса
Алгоритм адаптирует метод Брезенхэма для построения эллипса. Эллипс делится на две части: верхнюю и нижнюю. Считывает три точки, центр, ширину, длину, алгоритм вычисляет точки эллипса, используя решающую переменные $d_1$ и $d_2$. Верхняя и нижняя половина эллипса строится одновременно. Для каждой точки добавляются четыре симметричные точки относительно центра эллипса (rx, ry).

#### Первый этап (верхняя часть эллипса, пока $( b^2 x < a^2 y )$




$d_1 = b^2 (x+1)^2 + a^2 (y - 0.5)^2 - a^2 b^2$


Обновление параметров:
- Если $( d_1 < 0 )$, двигаемся вправо:  

  $d_1 = d_1 + 2b^2(x + 1) + b^2$
  
- Иначе двигаемся по диагонали:  
  
  $d_1 = d_1 + 2b^2(x + 1) - 2a^2(y - 1) + b^2$

#### Второй этап (нижняя часть эллипса, пока $( y \geq 0 )$

Решающая функция:


$d_2 = b^2 (x + 0.5)^2 + a^2 (y - 1)^2 - a^2 b^2$

Обновление параметров:
- Если $( d_2 > 0 )$, двигаемся вниз:  
  
  $d_2 = d_2 + a^2(-2y + 3)$
  
- Иначе двигаемся по диагонали:  
  
  $d_2 = d_2 + 2b^2(x + 1) + a^2(-2y + 3)$
  



### Алгоритм построения гиперболы
Алгоритм строит гиперболу, используя параметрическое уравнение. В зависимости от ориентации гиперболы (вертикальная или горизонтальная), он обходит значения y или x с шагом step и вычисляет соответствующие точки. Для каждой точки добавляются четыре симметричные точки относительно центра гиперболы (a, b). 
#### Первый этап (правая и левая ветви)

Решающая функция:


$d_1 = b^2 (x^2) - a^2 (y^2) - a^2 b^2$


Обновление параметров:
- Если $( d_1 < 0 )$, увеличиваем $( y )$:  
  
  $d_1 = d_1 + 2b^2(y + 1)$
  
- Иначе увеличиваем $( y )$ и уменьшаем $( x )$:  
  
  $d_1 = d_1 + 2b^2(y + 1) - 2a^2(x - 1)$
  

### Второй этап (верхняя и нижняя ветви)

Решающая функция:


$d_2 = b^2 (x - 0.5)^2 - a^2 (y + 1)^2 - a^2 b^2$


Обновление параметров:
- Если $( d_2 > 0 )$, уменьшаем $( x )$:  
  
  $d_2 = d_2 - 2a^2 x$
  
- Иначе увеличиваем $( y )$ и уменьшаем $( x )$:  
  
  $d_2 = d_2 + 2b^2(y + 1) - 2a^2x$
  


### Алгоритм построения параболы
Алгоритм строит параболу, используя параметрическое уравнение. В зависимости от ориентации параболы (вверх или вниз), он обходит значения y и вычисляет соответствующие значения x. Для каждого y добавляются две симметричные точки относительно оси параболы.

## Интерфейс
![image](https://github.com/user-attachments/assets/1131f36d-435c-4841-8f01-1cc7b6fe818b)



## Реализация
Функция выбора алгоритма для запуска:
```Python
    def capture_second_order_points(self, event):
        """Фиксирует точки для линий второго порядка."""
        x, y = self.canvas_view.get_coordinates(event)
        self.click_points.append([x, y])
        self.click_count += 1

        strategy = self.active_context.get_strategy()
        if not strategy:
            print("Ошибка: не выбрана стратегия рисования второго порядка.")
            return

        if strategy.name == "Окружность" and self.click_count == 2:
            # Окружность (2 клика)
            self.draw_second_order_shape(two_points=True)
        elif strategy.name in ["Эллипс", "Гипербола", "Парабола"] and self.click_count == 3:
            # Эллипс, гипербола, парабола (3 клика)
            self.draw_second_order_shape(two_points=False)
```

## Вывод
В ходе работы был создан простой графический редактор, позволяющий строить и визуализировать различные кривые, включая окружности, эллипсы, гиперболы и параболы.

</details>

<details>
  <summary>Лаб 3</summary>
  
## Цель
Разработать графический редактор, реализующий построение кривых Безье, Эрмита и B-сплайнов. Вызов способа генерации кривой задается из пункта меню и доступно через панель инструментов «Кривые». В редакторе кроме режима генерации кривых в пользовательском окне должен быть предусмотрен отладочный режим, где отображается пошаговое решение.

## Описание алгоритмов
### Кривая Безье
Кривая Безье строится с использованием полиномов Бернштейна. Для четырех контрольных точек P0, P1, P2, P3 кривая определяется как:
B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3, где t ∈ [0,1]

### Кривая Эрмита
Кривая Эрмита определяется двумя конечными точками P0, P3 и двумя касательными векторами R0, R1. Кривая проходит через конечные точки и имеет заданные касательные в этих точках.

### B-сплайн
B-сплайн строится с использованием базисных функций B-сплайна. Кривая не обязательно проходит через контрольные точки, но обеспечивает локальный контроль формы.

## Интерфейс
![image](https://github.com/user-attachments/assets/...)

## Реализация
```Python
class CurveStrategy:
    def draw(self, points, canvas):
        # Общий интерфейс для всех стратегий кривых
        pass

class BezierStrategy(CurveStrategy):
    def draw(self, points, canvas):
        # Реализация кривой Безье
        pass

class HermiteStrategy(CurveStrategy):
    def draw(self, points, canvas):
        # Реализация кривой Эрмита
        pass

class BSplineStrategy(CurveStrategy):
    def draw(self, points, canvas):
        # Реализация B-сплайна
        pass
```

## Вывод
В результате реализации графического редактора, использующего алгоритмы построения кривых (Безье, Эрмита и B-сплайн), была создана система, обеспечивающая интерактивное рисование кривых с возможностью просмотра пошагового процесса.

</details>

<details>
  <summary>Лаб 4</summary>
  
## Тема
Геометрические преобразования.
## Задание
Разработать элементарный графический редактор, реализующий геометрические преобразования в двумерном и трехмерном пространстве, а также перспективные преобразования. Для выполнения базовых геометрических преобразований разработать панель управления. В редакторе предусмотреть отладочный режим.
## Интерфейс
![image](https://github.com/user-attachments/assets/e8d79eb2-77cc-47ea-bb0a-2649c0a234f8)

## Вывод
В результате выполнения был реализован функционал рализующий геометрические преобразования в двумерном и трехмерном пространстве, а также перспективные преобразования.

</details>

<details>
  <summary>Лаб 5</summary>
  
## Цель
Разработать графический редактор, реализующий построение выпуклой оболочки множества точек. В редакторе должны быть реализованы два алгоритма:
- Алгоритм Джарвиса (Gift Wrapping)
- Алгоритм Грэхема (Graham Scan)

## Описание алгоритмов
### Алгоритм Джарвиса
1. Находим самую левую точку P0
2. Для каждой точки Pi находим такую точку Pj, что все остальные точки лежат справа от вектора PiPj
3. Повторяем шаг 2, пока не вернемся к начальной точке

### Алгоритм Грэхема
1. Находим самую нижнюю точку P0
2. Сортируем остальные точки по полярному углу относительно P0
3. Строим выпуклую оболочку, последовательно добавляя точки в стек и удаляя точки, которые нарушают выпуклость

## Интерфейс
![image](https://github.com/user-attachments/assets/...)

## Реализация
```Python
def jarvis(points):
    # Реализация алгоритма Джарвиса
    pass

def graham(points):
    # Реализация алгоритма Грэхема
    pass
```

## Вывод
В результате реализации графического редактора, использующего алгоритмы построения выпуклой оболочки, была создана система, обеспечивающая нахождение минимального выпуклого многоугольника, содержащего заданное множество точек.

</details>

## Технологии
- Python
- Tkinter
- NumPy (для математических вычислений)
- Opengl
- Pygame

## Установка и запуск
1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python main.py
```

## Структура проекта
