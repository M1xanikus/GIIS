# Графический интерфейс интеллектуальных систем. Графический редактор

<details>
  <summary>Лаб 1</summary>
  
## Цель
Разработать элементарный графический редактор, реализующий построение отрезков с помощью алгоритма ЦДА, целочисленного алгоритма Брезенхема и алгоритма Ву. Вызов способа генерации отрезка задается из пункта меню и доступно через панель инструментов «Отрезки». В редакторе кроме режима генерации отрезков в пользовательском окне должен быть предусмотрен отладочный режим, где отображается пошаговое решение на дискретной сетке.

## Описание алгоритмов
### Цифровой Дифференциальный Анализатор
Цифровой дифференциальный анализатор (ЦДА) – это алгоритм, основанный на аппроксимации прямой линии путем равномерного приращения координат. Он разбивает отрезок на равные шаги по одной из координат и вычисляет соответствующие значения другой координаты.

### Алгоритм Брезенхема
Алгоритм Брезенхема основан на выборе оптимального пикселя с использованием целочисленных вычислений. В отличие от ЦДА, он исключает необходимость работы с дробными числами, используя пошаговое накопление ошибки, чтобы принять решение о том, какой пиксель закрасить на следующем шаге.

### Алгоритм Ву
Алгоритм Ву предназначен для построения сглаженных (антиалиасинговых) линий. В отличие от Брезенхема, который выбирает один пиксель на каждом шаге, Ву использует два соседних пикселя, назначая им разные уровни яркости, чтобы сгладить границы линии и уменьшить эффект "ступенек" (aliasing).

## Интерфейс
![image](https://github.com/user-attachments/assets/212a9924-8095-4518-ab6f-4a810d94fda1)


## Реализация
Функция отрисовки точек из методички по алгоритму ЦДА:
```Python
    def execute(self, a, b, canvas, debugger=None):
        x1, y1 = a
        x2, y2 = b

        dx = x2 - x1
        dy = y2 - y1
        length = max(abs(dx), abs(dy))

        dx /= length
        dy /= length

        x = x1 + 0.5 * (1 if dx > 0 else -1 if dx < 0 else 0)
        y = y1 + 0.5 * (1 if dy > 0 else -1 if dy < 0 else 0)

        if debugger:
            debugger.record_step(int(x), int(y))

        for _ in range(int(length)):
            x += dx
            y += dy
            if debugger:
                debugger.record_step(int(x), int(y))
            else:
                self.plot(canvas, int(x), int(y))
```
Функция отрисовки точек по алгоритму Брезенхема:
```Python
    def execute(self, a, b, canvas, debugger=None):
        x1, y1 = a
        x2, y2 = b

        dx = abs(x2 - x1)
        dy = abs(y2 - y1)

        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1

        if dx > dy:
            e = 2 * dy - dx
            while x1 != x2:
                if debugger:
                    debugger.record_step(int(x1), int(y1))
                else:
                    self.plot(canvas, int(x1), int(y1), "black")
                if e >= 0:
                    y1 += sy
                    e -= 2 * dx
                x1 += sx
                e += 2 * dy
        else:
            e = 2 * dx - dy
            while y1 != y2:
                if debugger:
                    debugger.record_step(int(x1), int(y1))
                else:
                    self.plot(canvas, int(x1), int(y1), "black")
                if e >= 0:
                    x1 += sx
                    e -= 2 * dy
                y1 += sy
                e += 2 * dx

        if debugger:
            debugger.record_step(int(x1), int(y1))
        else:
            self.plot(canvas, int(x1), int(y1), "black")

```
Функция отрисовки точек по алгоритму Ву:
```Python
    def execute(self, a, b, canvas, debugger=None):
        """Алгоритм Ву с отладкой, без сглаживания для вертикальных и горизонтальных линий."""
        x1, y1 = a
        x2, y2 = b

        dx = abs(x2 - x1)
        dy = abs(y2 - y1)

        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1

        # Проверка на вертикальную линию (без сглаживания)
        if dx == 0:
            for y in range(y1, y2 + sy, sy):
                if debugger:
                    debugger.record_step(x1, y, 1.0)
                else:
                    self.plot(canvas, x1, y, 1.0)
            return

        # Проверка на горизонтальную линию (без сглаживания)
        if dy == 0:
            for x in range(x1, x2 + sx, sx):
                if debugger:
                    debugger.record_step(x, y1, 1.0)
                else:
                    self.plot(canvas, x, y1, 1.0)
            return

        # Для остальных линий используем сглаживание Ву
        if dx > dy:
            gradient = dy / dx
            y = y1 + 0.5
            for x in range(x1, x2 + sx, sx):
                y_int = int(y)
                frac = y - y_int  # Дробная часть

                if debugger:
                    debugger.record_step(x, y_int, 1 - frac)
                    debugger.record_step(x, y_int + sy, frac)
                else:
                    self.plot(canvas, x, y_int, 1 - frac)
                    self.plot(canvas, x, y_int + sy, frac)

                y += gradient * sy
        else:
            gradient = dx / dy
            x = x1 + 0.5
            for y in range(y1, y2 + sy, sy):
                x_int = int(x)
                frac = x - x_int  # Дробная часть

                if debugger:
                    debugger.record_step(x_int, y, 1 - frac)
                    debugger.record_step(x_int + sx, y, frac)
                else:
                    self.plot(canvas, x_int, y, 1 - frac)
                    self.plot(canvas, x_int + sx, y, frac)

                x += gradient * sx

        if debugger:
            debugger.record_step(x2, y2, 1.0)  # Последний пиксель
        else:
            self.plot(canvas, x2, y2, 1.0)
```

## Вывод
В результате реализации графического редактора, использующего алгоритмы построения отрезков (ЦДА, Брезенхема и Ву), была создана система, обеспечивающая интерактивное рисование отрезков с возможностью просмотра пошагового процесса.

</details>

<details>
  <summary>Лаб 2</summary>
  
## Цель
Разработать элементарный графический редактор, реализующий построение линий второго порядка. Вызов способа генерации линии второго порядка задается из пункта меню и доступно через панель инструментов «Линии 2-го порядка». В редакторе кроме режима генерации линий второго порядка в пользовательском окне должен быть предусмотрен отладочный режим, где отображается пошаговое решение на дискретной сетке.

## Описание алгоритмов
### Алгоритм построения окружности
Алгоритм использует метод Брезенхэма для построения окружности. Считывает две точки(x,y), вычисляет по ним радиус и вычисляет точки окружности в одном октанте, а затем симметрично отражает их в остальные семь октантов. Решающая переменная d определяет, какую точку выбрать на следующем шаге. Для каждой вычисленной точки добавляются восемь симметричных точек относительно центра окружности (cx, cy).

$d = 3 - 2 * radius$

### Алгоритм построения эллипса
Алгоритм адаптирует метод Брезенхэма для построения эллипса. Эллипс делится на две части: верхнюю и нижнюю. Считывает три точки, центр, ширину, длину, алгоритм вычисляет точки эллипса, используя решающую переменные $d_1$ и $d_2$. Верхняя и нижняя половина эллипса строится одновременно. Для каждой точки добавляются четыре симметричные точки относительно центра эллипса (rx, ry).

#### Первый этап (верхняя часть эллипса, пока $( b^2 x < a^2 y )$




$d_1 = b^2 (x+1)^2 + a^2 (y - 0.5)^2 - a^2 b^2$


Обновление параметров:
- Если $( d_1 < 0 )$, двигаемся вправо:  

  $d_1 = d_1 + 2b^2(x + 1) + b^2$
  
- Иначе двигаемся по диагонали:  
  
  $d_1 = d_1 + 2b^2(x + 1) - 2a^2(y - 1) + b^2$

#### Второй этап (нижняя часть эллипса, пока $( y \geq 0 )$

Решающая функция:


$d_2 = b^2 (x + 0.5)^2 + a^2 (y - 1)^2 - a^2 b^2$

Обновление параметров:
- Если $( d_2 > 0 )$, двигаемся вниз:  
  
  $d_2 = d_2 + a^2(-2y + 3)$
  
- Иначе двигаемся по диагонали:  
  
  $d_2 = d_2 + 2b^2(x + 1) + a^2(-2y + 3)$
  



### Алгоритм построения гиперболы
Алгоритм строит гиперболу, используя параметрическое уравнение. В зависимости от ориентации гиперболы (вертикальная или горизонтальная), он обходит значения y или x с шагом step и вычисляет соответствующие точки. Для каждой точки добавляются четыре симметричные точки относительно центра гиперболы (a, b). 
#### Первый этап (правая и левая ветви)

Решающая функция:


$d_1 = b^2 (x^2) - a^2 (y^2) - a^2 b^2$


Обновление параметров:
- Если $( d_1 < 0 )$, увеличиваем $( y )$:  
  
  $d_1 = d_1 + 2b^2(y + 1)$
  
- Иначе увеличиваем $( y )$ и уменьшаем $( x )$:  
  
  $d_1 = d_1 + 2b^2(y + 1) - 2a^2(x - 1)$
  

### Второй этап (верхняя и нижняя ветви)

Решающая функция:


$d_2 = b^2 (x - 0.5)^2 - a^2 (y + 1)^2 - a^2 b^2$


Обновление параметров:
- Если $( d_2 > 0 )$, уменьшаем $( x )$:  
  
  $d_2 = d_2 - 2a^2 x$
  
- Иначе увеличиваем $( y )$ и уменьшаем $( x )$:  
  
  $d_2 = d_2 + 2b^2(y + 1) - 2a^2x$
  


### Алгоритм построения параболы
Алгоритм строит параболу, используя параметрическое уравнение. В зависимости от ориентации параболы (вверх или вниз), он обходит значения y и вычисляет соответствующие значения x. Для каждого y добавляются две симметричные точки относительно оси параболы.

## Интерфейс
![image](https://github.com/user-attachments/assets/1131f36d-435c-4841-8f01-1cc7b6fe818b)



## Реализация
Функция выбора алгоритма для запуска:
```Python
    def capture_second_order_points(self, event):
        """Фиксирует точки для линий второго порядка."""
        x, y = self.canvas_view.get_coordinates(event)
        self.click_points.append([x, y])
        self.click_count += 1

        strategy = self.active_context.get_strategy()
        if not strategy:
            print("Ошибка: не выбрана стратегия рисования второго порядка.")
            return

        if strategy.name == "Окружность" and self.click_count == 2:
            # Окружность (2 клика)
            self.draw_second_order_shape(two_points=True)
        elif strategy.name in ["Эллипс", "Гипербола", "Парабола"] and self.click_count == 3:
            # Эллипс, гипербола, парабола (3 клика)
            self.draw_second_order_shape(two_points=False)
```

## Вывод
В ходе работы был создан простой графический редактор, позволяющий строить и визуализировать различные кривые, включая окружности, эллипсы, гиперболы и параболы.

</details>

<details>
  <summary>Лаб 3</summary>
  
## Цель
Разработать графический редактор, реализующий построение кривых Безье, Эрмита и B-сплайнов. Вызов способа генерации кривой задается из пункта меню и доступно через панель инструментов «Кривые». В редакторе кроме режима генерации кривых в пользовательском окне должен быть предусмотрен отладочный режим, где отображается пошаговое решение.

## Описание алгоритмов
### Кривая Безье
Кривая Безье строится с использованием полиномов Бернштейна. Для четырех контрольных точек P0, P1, P2, P3 кривая определяется как:
B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3, где t ∈ [0,1]

### Кривая Эрмита
Кривая Эрмита определяется двумя конечными точками P0, P3 и двумя касательными векторами R0, R1. Кривая проходит через конечные точки и имеет заданные касательные в этих точках.

### B-сплайн
B-сплайн строится с использованием базисных функций B-сплайна. Кривая не обязательно проходит через контрольные точки, но обеспечивает локальный контроль формы.

## Интерфейс
![image](https://github.com/user-attachments/assets/...)

## Реализация
```Python
class CurveStrategy:
    def draw(self, points, canvas):
        # Общий интерфейс для всех стратегий кривых
        pass

class BezierStrategy(CurveStrategy):
    def draw(self, points, canvas):
        # Реализация кривой Безье
        pass

class HermiteStrategy(CurveStrategy):
    def draw(self, points, canvas):
        # Реализация кривой Эрмита
        pass

class BSplineStrategy(CurveStrategy):
    def draw(self, points, canvas):
        # Реализация B-сплайна
        pass
```

## Вывод
В результате реализации графического редактора, использующего алгоритмы построения кривых (Безье, Эрмита и B-сплайн), была создана система, обеспечивающая интерактивное рисование кривых с возможностью просмотра пошагового процесса.

</details>

<details>
  <summary>Лаб 4</summary>
  
## Цель
Разработать графический редактор, реализующий анализ полигонов. В редакторе должны быть реализованы следующие функции:
- Проверка выпуклости полигона
- Определение принадлежности точки полигону
- Нахождение точек пересечения отрезка с полигоном

## Описание алгоритмов
### Проверка выпуклости
Полигон является выпуклым, если все его внутренние углы меньше 180 градусов. Проверка выполняется путем анализа знака векторного произведения для каждой тройки последовательных вершин.

### Принадлежность точки полигону
Используется алгоритм "Ray Casting" (метод лучей). Из точки проводится луч в произвольном направлении и подсчитывается количество пересечений с границей полигона.

### Пересечение отрезка с полигоном
Для каждого ребра полигона проверяется пересечение с заданным отрезком. Если пересечение найдено, вычисляется точка пересечения.

## Интерфейс
![image](https://github.com/user-attachments/assets/...)

## Реализация
```Python
def is_convex(polygon):
    # Проверка выпуклости полигона
    pass

def point_in_polygon(point, polygon):
    # Проверка принадлежности точки полигону
    pass

def segment_intersects_polygon(segment, polygon):
    # Нахождение точек пересечения отрезка с полигоном
    pass
```

## Вывод
В результате реализации графического редактора, использующего алгоритмы анализа полигонов, была создана система, обеспечивающая проверку свойств полигонов и их взаимодействие с другими геометрическими объектами.

</details>

<details>
  <summary>Лаб 5</summary>
  
## Цель
Разработать графический редактор, реализующий построение выпуклой оболочки множества точек. В редакторе должны быть реализованы два алгоритма:
- Алгоритм Джарвиса (Gift Wrapping)
- Алгоритм Грэхема (Graham Scan)

## Описание алгоритмов
### Алгоритм Джарвиса
1. Находим самую левую точку P0
2. Для каждой точки Pi находим такую точку Pj, что все остальные точки лежат справа от вектора PiPj
3. Повторяем шаг 2, пока не вернемся к начальной точке

### Алгоритм Грэхема
1. Находим самую нижнюю точку P0
2. Сортируем остальные точки по полярному углу относительно P0
3. Строим выпуклую оболочку, последовательно добавляя точки в стек и удаляя точки, которые нарушают выпуклость

## Интерфейс
![image](https://github.com/user-attachments/assets/...)

## Реализация
```Python
def jarvis(points):
    # Реализация алгоритма Джарвиса
    pass

def graham(points):
    # Реализация алгоритма Грэхема
    pass
```

## Вывод
В результате реализации графического редактора, использующего алгоритмы построения выпуклой оболочки, была создана система, обеспечивающая нахождение минимального выпуклого многоугольника, содержащего заданное множество точек.

</details>
<details>
  <summary>Лаб 6: Анализ и заливка полигонов</summary>

## Цель
Реализовать функции анализа свойств полигонов и алгоритмы их заливки.

## Функциональность
### Анализ
- **Проверка выпуклости:** Определяет, является ли выбранный полигон выпуклым.
- **Внутренние нормали:** Отображает внутренние нормали к ребрам полигона.
- **Пересечение с отрезком:** Позволяет нарисовать отрезок и найти точки его пересечения с выбранным полигоном.
- **Принадлежность точки:** Позволяет выбрать полигон и кликнуть в любую точку, чтобы определить, находится ли она внутри, снаружи или на границе полигона.
### Заливка
- **Растровая развёртка с ET/AEL:** Заливает полигон, используя списки активных ребер и таблицу ребер.
- **Flood Fill (рекурсивный):** Заливает область, начиная с затравки, рекурсивно окрашивая соседние пиксели.
- **Scanline Seed Fill (построчный с затравкой):** Заливает область, используя стек и обрабатывая пиксели построчно, начиная с затравки.

## Интерфейс 
![image](https://github.com/user-attachments/assets/846d6098-9705-45d0-badc-fc335d10744f)
## Использование
### Анализ
1. Убедитесь, что на холсте есть хотя бы один полигон (созданный с помощью инструмента "Выпуклая оболочка").
2. Выберите нужную операцию анализа из меню "Анализ полигона".
3. Следуйте инструкциям (выберите полигон, нарисуйте отрезок или кликните точку).
### Заливка
1. Выберите инструмент "Заливка полигона" на панели инструментов.
2. Выберите алгоритм заливки из выпадающего меню.
3. Нажмите кнопку "Цвет заливки" и выберите желаемый цвет.
4. Кликните на полигон, который хотите залить.
5. Если выбран алгоритм с затравкой, кликните второй раз внутри полигона для указания начальной точки заливки.

</details>

<details open>
  <summary>Лаб 7: Диаграмма Вороного и триангуляция Делоне</summary>

## Цель
Реализовать построение диаграммы Вороного и триангуляции Делоне для заданного набора точек.

## Теория
### Диаграмма Вороного
Диаграмма Вороного для набора точек (сайтов) делит плоскость на регионы (ячейки) так, что каждая ячейка содержит точки, для которых данный сайт является ближайшим. Границы ячеек лежат на серединных перпендикулярах между парами сайтов. Применяется для задач поиска ближайшего соседа, определения зон влияния и др.

### Триангуляция Делоне
Триангуляция Делоне соединяет набор точек треугольниками так, что описанная окружность любого треугольника не содержит внутри других точек из набора (свойство пустой окружности). Эта триангуляция максимизирует минимальный угол треугольников, что полезно для интерполяции, построения сеток и поверхностей.

### Связь
Диаграмма Вороного и триангуляция Делоне являются дуальными структурами.

## Использование
1. Выберите инструмент "Диагр./Трианг." на панели инструментов.
2. Выберите "Триангуляция Делоне" или "Диаграмма Вороного" из выпадающего меню.
3. Кликайте на холсте для добавления точек (сайтов). Они будут отображаться как красные точки.
4. Когда добавлено достаточное количество точек (>= 2 для Вороного, >= 3 для Делоне), кнопка "Построить" станет активной.
5. Нажмите "Построить" для визуализации результата на холсте.
   *   Триангуляция Делоне отображается синими линиями.
   *   Диаграмма Вороного отображается зелеными (конечные ребра) и оранжевыми (бесконечные ребра) линиями.
## Интерфейс
![image](https://github.com/user-attachments/assets/c25a670f-2d79-4581-a1b0-caa593c2c797)
![image](https://github.com/user-attachments/assets/c2cba24f-9aec-4064-84e4-12234201de7d)

## Отладка (Пошаговая визуализация)
1. Включите режим отладки: Меню "Отладка" -> "Отладка Вороной/Делоне (Пошагово)".
2. Выполните шаги 1-4 из раздела "Использование".
3. Нажмите "Построить". Откроется отдельное окно отладчика.
4. Используйте кнопки "Следующий шаг >>" и "<< Предыдущий шаг" для просмотра построения структуры.
   *   Текущий добавляемый элемент (треугольник или ребро) будет выделен (более толстая линия, другой цвет).

</details>
## Технологии
- Python
- Tkinter
- NumPy (для математических вычислений)
- Pillow (для работы с изображениями)

## Установка и запуск
1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python main.py
```

## Структура проекта
